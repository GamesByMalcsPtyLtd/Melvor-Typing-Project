interface BaseSkillData {
    /** IDs of pets to register to skill */
    pets?: string[];
    /** Rare drops that may drop on each action of the skill */
    rareDrops?: RareSkillDropData[];
    /** Information on what should appear on a skill's minibar */
    minibar?: MinibarData;
    /** Custom milestones that are not autogenerated */
    customMilestones?: MilestoneData[];
    /** The sets of ancient relics for this skill per realm */
    ancientRelicSets?: AncientRelicSetData[];
    /**
     * Ancient Relics assigned to the Skill
     * @deprecated Use ancientRelicSets instead
     */
    ancientRelics?: AncientRelicDropData[];
    /**
     * The Ancient Relic that is activated when all 5 skill relics are obtained
     * @deprecated Use ancientRelicSets instead
     */
    completedAncientRelic?: string;
    /** Determines the Skill Tree */
    skillTrees?: SkillTreeData[];
    /** Optional. Requirements that must be met to unlock the skill. */
    unlockRequirements?: AnyRequirementData[];
    /** Optional. Whether this Skill has Abyssal Levels. Defaults to false if not set. */
    hasAbyssalLevels?: boolean;
    /** Shop upgrade chains that should show in the skill's header */
    headerUpgradeChains?: string[];
    /** Items with charges that should show in the skill's header */
    headerItemCharges?: string[];
    /** Optional. Sets a realm that this skills standard levels are tied to */
    standardLevelRealm?: string;
    /** Optional. Sets a realm that this skills abyssal levels are tied to */
    abyssalLevelRealm?: string;
}
interface BaseSkillModificationData {
}
interface RareSkillDropData {
    /** Item that drops */
    itemID: string;
    altItemID?: string;
    /** The quantity of the item that drops */
    quantity: number;
    /** Chance for the drop */
    chance: RareSkillDropChance;
    /** Requirements for the drop */
    requirements: AnyRequirementData[];
    /** Determines which gamemodes this drop is exclusive to */
    gamemodes?: string[];
    /** Determines which realms this drop can be obtianed from */
    realms?: string[];
}
declare type RareSkillDropChance = FixedSkillDropChance | LevelScalingSkillDropChance | TotalMasteryScalingSkillDropChance;
declare type FixedSkillDropChance = {
    type: 'Fixed';
    chance: number;
};
interface ScalingChance {
    baseChance: number;
    scalingFactor: number;
    maxChance: number;
}
interface LevelScalingSkillDropChance extends ScalingChance {
    type: 'LevelScaling';
}
interface TotalMasteryScalingSkillDropChance extends ScalingChance {
    type: 'TotalMasteryScaling';
}
interface RareSkillDrop {
    /** The item that drops */
    item: AnyItem;
    altItem?: AnyItem;
    /** The quantity of the item that drops */
    quantity: number;
    /** The chance for the item to drop */
    chance: RareSkillDropChance;
    /** The requirements for the item to drop */
    requirements: AnyRequirement[];
    /** Determines the gamemodes this drop is exclusive to */
    gamemodes?: Gamemode[];
    /** Determines the realms this drop is exclusive to */
    realms: Set<Realm>;
}
interface MinibarData {
    /** Items that by default should be in the minibar item selection */
    defaultItems: string[];
    /** Shop Upgrades that should display on the minibar */
    upgrades: string[];
    /** Pets that should display on the minibar */
    pets: string[];
}
interface MinibarOptions {
    defaultItems: Set<EquipmentItem>;
    upgrades: ShopPurchase[];
    pets: Pet[];
}
interface LevelCompletionBreakdown {
    /** The completion namespace this block of levels belongs to */
    namespace: CompletionNamespace;
    /** The number of levels that belong to the namespace */
    levels: number;
}
declare const TOTH_SKILL_LEVEL_BREAKDOWN: LevelCompletionBreakdown[];
declare class SkillRenderQueue {
    xp: boolean;
    level: boolean;
    xpCap: boolean;
    levelCapPurchase: boolean;
    abyssalLevelCapPurchase: boolean;
    /** The previous level that was rendered */
    previousLevel: number;
    lock: boolean;
    ancientRelics: boolean;
    abyssalXP: boolean;
    abyssalLevel: boolean;
    /** The previous level that was rendered */
    previousAbyssalLevel: number;
    /** Render realm selection element */
    realmSelection: boolean;
    /** Render respective realm visibility */
    realmVisibility: Set<Realm>;
    /** Updates the visibility of this skill's levels in the UI */
    levelVisibility: boolean;
    /** Updates the visibility of this skill's abyssal levels in the UI */
    abyssalLevelVisibility: boolean;
}
declare class SkillLevelChangedEvent extends GameEvent {
    skill: AnySkill;
    oldLevel: number;
    newLevel: number;
    constructor(skill: AnySkill, oldLevel: number, newLevel: number);
}
declare class SkillXPEarnedEvent extends GameEvent {
    skill: AnySkill;
    oldXP: number;
    newXP: number;
    constructor(skill: AnySkill, oldXP: number, newXP: number);
}
declare type SkillEvents = {
    xpEarned: SkillXPEarnedEvent;
    abyssalXPEarned: SkillXPEarnedEvent;
    levelChanged: SkillLevelChangedEvent;
    abyssalLevelChanged: SkillLevelChangedEvent;
};
declare type SkillModifierQueryParams = Omit<IModifierScope, 'subcategory'> & {
    subcategory?: NamedObject | NamedObject[];
};
/** Base class for all skills */
declare abstract class Skill<DataType extends BaseSkillData, Events extends SkillEvents = SkillEvents, ModificationDataType extends BaseSkillModificationData = BaseSkillModificationData> extends NamespacedObject implements EncodableObject, INoWildCardGameEventEmitter<Events>, IModifierScopeSource {
    /** Game object to which this skill is registered to */
    game: Game;
    _events: Pick<Emitter<Events>, 'emit'>;
    on: INoWildCardGameEventEmitter<Events>['on'];
    off: INoWildCardGameEventEmitter<Events>['off'];
    providedStats: StatProvider;
    /** Readonly. Returns the current level of the skill. */
    get level(): number;
    /** Readonly. Returns the current xp of the skill */
    get xp(): number;
    /** Readonly. Returns the percent progress of the skill to the next level */
    get nextLevelProgress(): number;
    /** Readonly. Returns the percent progress of the skill to the next level */
    get nextAbyssalLevelProgress(): number;
    /** Readonly. Localized name of skill */
    get name(): string;
    /** Readonly: URL of skills icon image */
    get media(): string;
    get hasMastery(): boolean;
    /** If the skill is a combat skill or not */
    get isCombat(): boolean;
    /** Readonly: If the skill has a Skilling Minibar */
    get hasMinibar(): boolean;
    /** Readonly. Returns the current abyssal xp of the skill */
    get abyssalXP(): number;
    /** Readonly. Returns the current abyssal level of the skill */
    get abyssalLevel(): number;
    /** Pets that can be rolled after completing an action for the skill */
    pets: Pet[];
    /** Rare item drops that occur on an action */
    rareDrops: RareSkillDrop[];
    /** Stores the sets of ancient relics for each realm */
    ancientRelicSets: Map<Realm, AncientRelicSet>;
    /** Returns if this skill has ancient relics */
    get hasAncientRelics(): boolean;
    /** Skill Trees for this skill */
    skillTrees: NamespaceRegistry<SkillTree>;
    /** Requirements that must be met to unlock this skill */
    unlockRequirements: AnyRequirement[];
    /** Event Unhandling methods for skill unlocking */
    unlockUnlisteners: VoidFunction[];
    readonly BASE_CORRUPT_CHANCE = 5;
    minibarOptions: MinibarOptions;
    milestones: MilestoneLike[];
    abyssalMilestones: AbyssalMilestoneLike[];
    /** Sorts the milestones by skill level (ascending) */
    sortMilestones(): void;
    /** Readonly. Returns the current virtual level of the skill */
    get virtualLevel(): number;
    /** Readonly. Returns the current virtual abyssal level of the skill */
    get virtualAbyssalLevel(): number;
    /** The absolute maximum skill level achievable */
    get maxLevelCap(): number;
    _currentLevelCap: number;
    /** If a level cap has been set for this skill */
    get levelCapSet(): boolean;
    /** The current maximum skill level achievable, factoring in gamemode/other restrictions */
    get currentLevelCap(): number;
    /** The absolute maximum abyssal level achievable */
    get maxAbyssalLevelCap(): number;
    _currentAbyssalLevelCap: number;
    /** If an abyssal level cap has been set for this skill */
    get abyssalLevelCapSet(): boolean;
    /** The current maximum abyssal level achievable, factoring in gamemode/other restrictions */
    get currentAbyssalLevelCap(): number;
    isGatingLevelCapPurchases: boolean;
    isGatingAbyssalLevelCapPurchases: boolean;
    levelCapButtons: LevelCapPurchaseButtonElement[];
    abyssalLevelCapButtons: LevelCapPurchaseButtonElement[];
    headerUpgradeChains: ShopUpgradeChain[];
    headerItemCharges: EquipmentItem[];
    header?: SkillHeaderElement;
    /** The level the skill should start at */
    get startingLevel(): number;
    /** The abyssal level the skill should start at */
    get startingAbyssalLevel(): number;
    /** Maximum skill level achievable during the tutorial */
    get tutorialLevelCap(): number;
    /** A breakdown of which levels of this skill are associated with each completion category */
    get levelCompletionBreakdown(): LevelCompletionBreakdown[];
    /** A breakdown of which abyssal levels of this skill are associated with each completion category */
    get abyssalLevelCompletionBreakdown(): LevelCompletionBreakdown[];
    get isUnlocked(): boolean;
    get hasSkillTree(): boolean;
    /** Stores the current level of the skill */
    _level: number;
    /** Stores the current xp of the skill */
    _xp: number;
    /** Stores the current abyssal level of the skill */
    _abyssalLevel: number;
    /** Stores the current abyssal xp of the skill */
    _abyssalXP: number;
    /** Stores if the skill is unlocked */
    _unlocked: boolean;
    /** Media of string without CDN */
    abstract readonly _media: string;
    /** Determines whether this skill has abyssal levels */
    _hasAbyssalLevels: boolean;
    get hasAbyssalLevels(): boolean;
    /** Realm tied to the standard levels of this skill. If present, standard levels will not render unless this realm is unlocked */
    standardLevelRealm?: Realm;
    /** Realm tied to the abyssal levels of this skill. If present, abyssal levels will not render unless this realm is unlocked */
    abyssalLevelRealm?: Realm;
    /** If the standard levels of this skill should be shown in the UI */
    get shouldShowStandardLevels(): boolean;
    /** If the abyssal levels of this skill should be shown in the UI */
    get shouldShowAbyssalLevels(): boolean;
    currentRealm: Realm;
    realmSelect?: RealmSelectMenuElement;
    get availableRealmCount(): number;
    timeToLevelTracker: Map<number, number>;
    timeToLevelTicks: number;
    timeToLevelPercentStart: number;
    abstract renderQueue: SkillRenderQueue;
    readonly modQuery: ModifierQuery;
    constructor(namespace: DataNamespace, id: string, 
    /** Game object to which this skill is registered to */
    game: Game);
    getItemForRegistration(id: string): AnyItem;
    /** Gets the realm options that should show for this skill in a RealmSelectMenuElement */
    getRealmOptions(): Realm[];
    /** Callback function for when the current realm for this skill is changed */
    selectRealm(realm: Realm): void;
    /** Queues rendering changes for this skill when the current realm changes */
    onRealmChange(): void;
    /** Initializes menus for this skill */
    initMenus(): void;
    onLoad(): void;
    /**
     * Recomputes the stats provided by this skill
     * @param updatePlayer If the stats of the player should be recomputed
     */
    computeProvidedStats(updatePlayer?: boolean): void;
    /** Adds any stats that this skill provides to it's StatProvider interface members */
    addProvidedStats(): void;
    render(): void;
    renderXP(): void;
    renderLevel(): void;
    renderAbyssalXP(): void;
    renderAbyssalLevel(): void;
    renderLockStatus(): void;
    renderRealmSelection(): void;
    renderRealmVisibility(): void;
    renderLevelVisibility(): void;
    renderAbyssalLevelVisibility(): void;
    fireLevelUpModal(previousLevel: number): void;
    fireAbyssalLevelUpModal(previousLevel: number): void;
    getNewMilestoneHTML(previousLevel: number): string;
    /** Gets the HTML for Abyssal level milestones for use in the level up modal */
    getNewAbyssalMilestoneHTML(previousLevel: number): string;
    /** Rendering for the xp cap message */
    renderXPCap(): void;
    renderLevelCapPurchase(): void;
    renderAbyssalLevelCapPurchase(): void;
    /**
     * Adds experience to the skill
     * @param amount The unmodified experience to add
     * @param action Optional, the action the xp came from
     * @returns True if the xp added resulted in a level increase
     */
    addXP(amount: number, action?: NamedObject): boolean;
    /**
     * Adds Abyssal XP to the skill
     * @param amount The unmodified experience to add
     * @param action Optional, the action the xp came from
     * @returns True if the abyssal xp added resulted in a level increase
     */
    addAbyssalXP(amount: number, action?: NamedObject): boolean;
    /** Caps skill experience during the tutorial */
    capXPForTutorial(): void;
    /** Caps skill experience based on the current gamemode */
    capXPForGamemode(): void;
    /** Caps abyssal experience based on the current gamemode */
    capAXPForGamemode(): void;
    isLevelCapBelow(cap: number): boolean;
    applyLevelCapIncrease(increase: SkillCapIncrease): void;
    increaseLevelCap(amount: number, max?: number): void;
    applySetLevelCap(newCap: number): void;
    setLevelCap(newCap: number): void;
    isAbyssalLevelCapBelow(cap: number): boolean;
    applyAbyssalLevelCapIncrease(increase: SkillCapIncrease): void;
    increaseAbyssalLevelCap(amount: number, max?: number): void;
    applySetAbyssalLevelCap(newCap: number): void;
    setAbyssalLevelCap(count: number): void;
    /** Method for performing a level up on this skill */
    levelUp(): void;
    /** Method for performing an abyssal level up on this skill */
    abyssalLevelUp(): void;
    actionQueryCache: Map<NamedObject | undefined, ModifierQuery>;
    getActionModifierQuery(action?: NamedObject): ModifierQuery;
    acionItemQueryCache: Map<NamedObject | undefined, ModifierQuery>;
    getActionItemModifierQuery(action?: NamedObject): ModifierQuery;
    /**
     * Gets a modifier scope for this skill
     * @param action Optional action to apply to the scope
     */
    getActionModifierQueryParams(action?: NamedObject): SkillModifierQueryParams;
    getCurrencyModifierQuery(currency: Currency, action?: NamedObject): ModifierQuery;
    itemQueryCache: Map<Item, ModifierQuery>;
    getItemModifierQuery(item: Item): ModifierQuery;
    /**
     * Gets the modified xp to add to the skill
     * @param amount The unmodified experience
     * @param action Optional, the action the xp came from
     * @returns The experience with modifiers applied
     */
    modifyXP(amount: number, action?: NamedObject): number;
    _buildXPSources(action?: NamedObject): ModifierSourceBuilder;
    getXPSources(action?: NamedObject): HTMLSpanElement[];
    /**
     * Gets the modified abyssal xp to add to the skill
     * @param amount The unmodified experience
     * @param action Optional, the action the abyssal xp came from
     * @returns The experience with modifiers applied
     */
    modifyAbyssalXP(amount: number, action?: NamedObject): number;
    _buildAbyssalXPSources(action?: NamedObject): ModifierSourceBuilder;
    getAbyssalXPSources(action?: NamedObject): HTMLSpanElement[];
    /**
     * Gets the percentage xp modifier for a skill
     * @param action Optional, the action the xp came from
     */
    getXPModifier(action?: NamedObject): number;
    /**
     * Gets the percentage abyssal xp modifier for a skill
     * @param action Optional, the action the abyssal xp came from
     */
    getAbyssalXPModifier(action?: NamedObject): number;
    /** Gets the uncapped doubling chance for this skill.
     *  This should be overrode to add skill specific bonuses
     */
    getUncappedDoublingChance(action?: NamedObject): number;
    /** Gets the clamped doubling chance for this skill */
    getDoublingChance(action?: NamedObject): number;
    _buildDoublingSources(action?: NamedObject): ModifierSourceBuilder;
    /** Gets the sources of item doubling for this skill */
    getDoublingSources(action?: NamedObject): HTMLSpanElement[];
    /**
     * Gets the uncapped cost reduction for this skill
     * @param action Optional action to provide for action specific modifiers
     * @param item Optional item to provide for item specific modifiers
     * @returns The uncapped percentage cost reduction
     * @virtual
     */
    getUncappedCostReduction(action?: NamedObject, item?: AnyItem): number;
    /**
     * Gets the clamped cost reduction for this skill
     * @param action Optional action to provide for action specific modifiers
     * @param item Optional item to provide for item specific modifiers
     * @returns The percentage reduction clamped to the maximum value
     */
    getCostReduction(action?: NamedObject, item?: AnyItem): number;
    _buildCostReductionSources(action?: NamedObject): ModifierSourceBuilder;
    getCostReductionSources(action?: NamedObject): HTMLSpanElement[];
    /**
     * Gets the flat cost reduction for this skill
     * @param action Optional action to provide for action specific modifiers
     * @param item Optional item to provide for item specific modifiers
     */
    getFlatCostReduction(action?: NamedObject, item?: AnyItem): number;
    /** Modifies the cost of a specific item for a recipe */
    modifyItemCost(item: AnyItem, quantity: number, recipe: NamedObject): number;
    /** Modifies the cost of a specific currency for a recipe */
    modifyCurrencyCost(currency: Currency, quantity: number, recipe: NamedObject): number;
    /** Gets the flat change in [ms] for the given action */
    getFlatIntervalModifier(action?: NamedObject): number;
    _buildFlatIntervalSources(action?: NamedObject): ModifierSourceBuilder;
    getFlatIntervalSources(action?: NamedObject): HTMLSpanElement[];
    /** Gets the percentage change in interval for the given action */
    getPercentageIntervalModifier(action?: NamedObject): number;
    _buildPercentageIntervalSources(action?: NamedObject): ModifierSourceBuilder;
    getPercentageIntervalSources(action?: NamedObject): HTMLSpanElement[];
    getIntervalSources(action?: NamedObject): HTMLSpanElement[];
    modifyInterval(interval: number, action?: NamedObject): number;
    /** Gets the flat increase to the base quantity of the primary product produced by this skill */
    getFlatBasePrimaryProductQuantityModifier(item: Item, query: ModifierQuery): number;
    /** Gets any random increases to the base quantity of the primary product produced by this skill */
    getRandomFlatBasePrimaryProductQuantity(item: Item, query: ModifierQuery): number;
    /** Gets the percentage increase to the base quantity of the primary product produced by this skill */
    getBasePrimaryProductQuantityModifier(item: Item, query: ModifierQuery): number;
    /** Applies multipliers to the quantity of the primary product produced by this skill */
    applyPrimaryProductMultipliers(item: Item, quantity: number, action: NamedObject, query: ModifierQuery): number;
    getRandomFlatAdditionalPrimaryProductQuantity(item: Item, action: NamedObject, query: ModifierQuery): number;
    /** Gets the additional resource quantity in the skill. Cannot be doubled. */
    getFlatAdditionalPrimaryProductQuantity(item: Item, query: ModifierQuery): number;
    _buildAdditionalPrimaryResourceQuantitySources(query: ModifierQuery): ModifierSourceBuilder;
    getAdditionalPrimaryResourceQuantitySources(query: ModifierQuery): HTMLSpanElement[];
    /**
     * Calculates the minimum base quantity of the primary product given by this skill
     * @param item The product being given
     * @param quantity The un-modified base quantity
     * @param scope The scoping to apply to modifiers
     * @returns The minimum guaranteed quantity produced
     */
    getMinimumPrimaryProductBaseQuantity(item: Item, quantity: number, query: ModifierQuery): number;
    /**
     * Modifies the quantity of a primary product given by this skill
     * @param item The item being produced
     * @param quantity The original base quantity of the product
     * @param query The scoping to apply to modifiers
     * @returns The modified product. Minimum of 1.
     */
    modifyPrimaryProductQuantity(item: Item, quantity: number, action: NamedObject): number;
    addCurrencyFromPrimaryProductGain(rewards: Rewards, item: Item, quantity: number, action: NamedObject): void;
    /** Gets the preservation chance for the skill for a given action */
    getPreservationChance(action: NamedObject): number;
    _buildPreservationSources(action: NamedObject): ModifierSourceBuilder;
    getPreservationSources(action: NamedObject): HTMLSpanElement[];
    /** Gets the maximum preservation change for a skill */
    getPreservationCap(action?: NamedObject): number;
    /**
     * Gets the percentage modifier to apply to a currency reward
     * @param currency The currency to reward
     * @param action Optional. The action the currency is being rewarded for
     */
    getCurrencyModifier(currency: Currency, action?: NamedObject): number;
    /**
     * Gets the flat modifier to apply to a currency reward, after applying the percentage modifier
     * @param currency The currency to reward
     * @param action Optional. The action the currency is being rewarded for
     */
    getFlatCurrencyModifier(currency: Currency, action?: NamedObject): number;
    /**
     * Modifies a currency reward
     * @param currency The currency to reward
     * @param amount The base amount of currency
     * @param action Optional. The action the currency is being rewarded for
     */
    modifyCurrencyReward(currency: Currency, amount: number, action?: NamedObject): number;
    /** Sets the experience of the skill to the specified value */
    setXP(value: number): void;
    /** Sets the abyssal experience of the skill to the specified value */
    setAbyssalXP(value: number): void;
    setUnlock(isUnlocked: boolean): void;
    /** Called when the lock status of this skill has changed */
    onUnlock(): void;
    /** Callback function for attempted to unlock the skill */
    unlockOnClick(): void;
    assignUnlockListeners(): void;
    unassignUnlockListeners(): void;
    autoUnlock(): void;
    rollForPets(interval: number): void;
    /** Method called when skill is leveled up */
    onLevelUp(oldLevel: number, newLevel: number): void;
    /** Method called when skill is leveled up */
    onAbyssalLevelUp(oldLevel: number, newLevel: number): void;
    /** Method called when the standard or abyssal level of this skill increases */
    onAnyLevelUp(): void;
    isCorrectGamemodeForRareDrop(drop: RareSkillDrop): boolean;
    isCorrectRealmForRareDrop(drop: RareSkillDrop, realm: Realm): boolean;
    /** Rolls for additional items from modifiers */
    rollForAdditionalItems(rewards: Rewards, interval: number, action?: NamedObject): void;
    rollForRareDrops(level: number, rewards: Rewards, action?: NamedRealmedObject | undefined): void;
    rollForAncientRelics(level: number, realm: Realm): void;
    rollForAncientRelic(level: number, realm: Realm, drop: AncientRelicDrop): boolean;
    /** Unlocks ancient relics on leveling up this skill */
    unlockAncientRelicsOnLevelUp(oldLevel: number, newLevel: number): void;
    /** Unlocks ancient relics upon an abyssal level up of this skill */
    unlockAncientRelicsOnAbyssalLevelUp(oldLevel: number, newLevel: number): void;
    /** Unlocks a number of ancient relic drops from a relic set */
    unlockRelicDrops(relicSet: AncientRelicSet, count: number): void;
    getRareDropChance(level: number, chance: RareSkillDropChance): number;
    /** Callback function for showing the milestones for this skill */
    openMilestoneModal(): void;
    getRegistry(type: ScopeSourceType): NamespaceRegistry<NamedObject> | undefined;
    getPkgObjects(pkg: GameDataPackage, type: ScopeSourceType): IDData[] | undefined;
    encode(writer: SaveWriter): SaveWriter;
    /** Flags if the currentRealm property failed to load from a save */
    realmLoadFailed: boolean;
    decode(reader: SaveWriter, version: number): void;
    convertOldXP(xp: number): void;
    /** Temp variable used to store equipment milestones before categorizing into standard/abyssal */
    equipMilestones: EquipItemMilestone[];
    registerData(namespace: DataNamespace, data: DataType): void;
    /** Applies modifications to the data registered to this skill */
    modifyData(data: ModificationDataType): void;
    /** Method called after all game data has been registered. */
    postDataRegistration(): void;
    testTranslations(): void;
    /** Gets the set of items that are obtainable for this skill. Used for testing if all items can be obtained */
    getObtainableItems(): Set<AnyItem>;
    getAncientRelicsSnapshot(): Map<AncientRelic, number>;
    locateAncientRelic(relicSet: AncientRelicSet, relic: AncientRelic): void;
    hasMasterRelic(realm: Realm): boolean;
    onAncientRelicUnlock(): void;
    queueAncientRelicFoundModal(relicSet: AncientRelicSet, ancientRelic: AncientRelic): void;
    /** Callback function for opening the skill tree modal */
    openSkillTreeModal(): void;
}
interface ActionMastery {
    xp: number;
    level: number;
}
interface MasteryLevelUnlockData {
    /** Utilized only for game bonuses, gives language ID */
    descriptionID?: number;
    description: string;
    level: number;
}
declare class MasteryLevelUnlock {
    skill: SkillWithMastery<MasteryAction, MasterySkillData>;
    level: number;
    get description(): string;
    _descriptionID?: number;
    _description: string;
    constructor(data: MasteryLevelUnlockData, skill: SkillWithMastery<MasteryAction, MasterySkillData>);
}
interface MasteryLevelBonusData {
    /** The base modifiers to apply for this bonus. Action scoped modifiers should specify a default action that will be replaced. */
    modifiers: ModifierValuesRecordData;
    /** If the modifiers of this bonus should be scoped to the mastery action. Defaults to true. */
    autoScopeToAction?: boolean;
    /** The mastery level at which this bonus is applies, or starts to be applied for scaling bonuses */
    level: number;
    /** Optional. If present this bonus will scale up every X levels, X being equal to this value. */
    levelScalingSlope?: number;
    /** Optional. If present this bonus will stop scaling up at this level */
    levelScalingMax?: number;
    /** Optional. Filter to apply based on the action. Acceptable values depend on the skill. */
    filter?: string;
}
declare class MasteryLevelBonus implements SoftDataDependant<MasteryLevelBonusData> {
    /** The base modifiers to apply for this bonus */
    modifiers: ModifierValue[];
    /** If the modifiers for this bonus should automatically be scoped to the mastery action */
    autoScopeToAction: boolean;
    /** The mastery level at which this bonus is applied */
    level: number;
    /** If present, the modifiers from this bonus scale up every X levels, X equal to this value */
    levelScalingSlope?: number;
    /** If present, the modifier scaling for this bonus stop at this level */
    levelScalingMax?: number;
    /** Filter to apply based on the action. Acceptable values depend on the skill. */
    filter?: string;
    constructor(data: MasteryLevelBonusData, game: Game);
    registerSoftDependencies(data: MasteryLevelBonusData, game: Game): void;
    /** Returns the scaling that should be applied to this bonuses moodifiers for a given mastery level */
    getBonusScale(masteryLevel: number): {
        scale: number;
        effectiveLevel: number;
    };
    /** Returns modifiers for this bonus that are scoped to the given action */
    getScopedModifiers(action: NamedObject): ModifierValue[];
}
interface MasteryPoolBonusData {
    /** The ID of the Realm that this bonus belongs to */
    realm: string;
    /** The modifiers provided to the player when this bonus is active */
    modifiers: ModifierValuesRecordData;
    /** The percent that the mastery pool must be full to for this bonus to be active */
    percent: number;
}
declare class MasteryPoolBonus implements SoftDataDependant<MasteryPoolBonusData> {
    realm: Realm;
    modifiers: ModifierValue[];
    percent: number;
    constructor(data: MasteryPoolBonusData, game: Game);
    registerSoftDependencies(data: MasteryPoolBonusData, game: Game): void;
}
/** Base Data type for skills which have mastery */
interface MasterySkillData extends BaseSkillData {
    /** Optional. Data for mastery level unlocks for this skill */
    masteryLevelUnlocks?: MasteryLevelUnlockData[];
    /** Optional. Defines mastery level bonuses that are provided by this skill */
    masteryLevelBonuses?: MasteryLevelBonusData[];
    /** Optional. Defines mastery pool bonuses (checkpoints) that are provided by this skill */
    masteryPoolBonuses?: MasteryPoolBonusData[];
}
interface MasterySkillModificationData extends BaseSkillModificationData {
}
declare class MasterySkillRenderQueue<ActionType extends MasteryAction> extends SkillRenderQueue {
    actionMastery: Set<ActionType>;
    masteryPool: Set<Realm>;
}
declare class MasteryLevelChangedEvent extends GameEvent {
    skill: SkillWithMastery<MasteryAction, MasterySkillData>;
    action: MasteryAction;
    oldLevel: number;
    newLevel: number;
    constructor(skill: SkillWithMastery<MasteryAction, MasterySkillData>, action: MasteryAction, oldLevel: number, newLevel: number);
}
declare type SkillWithMasteryEvents = {
    masteryLevelChanged: MasteryLevelChangedEvent;
} & SkillEvents;
/** Base class for skills that have mastery */
declare abstract class SkillWithMastery<ActionType extends MasteryAction, DataType extends MasterySkillData, Events extends SkillWithMasteryEvents = SkillWithMasteryEvents, ModificationDataType extends MasterySkillModificationData = MasterySkillModificationData> extends Skill<DataType, Events, ModificationDataType> implements Action {
    get hasMastery(): boolean;
    actions: NamespaceRegistry<ActionType>;
    actionMastery: Map<MasteryAction, ActionMastery>;
    /** Save state property. Stores the mastery pool XP for each Realm */
    _masteryPoolXP: SparseNumericMap<Realm>;
    get masteryLevelCap(): number;
    /** Cache of Mastery Tokens which can be utilized for this skill per realm */
    masteryTokens: Map<Realm, MasteryTokenItem[]>;
    /** Readonly. Returns the percent of the base mastery pool xp the skill an reach */
    get masteryPoolCapPercent(): number;
    /** The chance to recieve a mastery token for this skill per action */
    get masteryTokenChance(): number;
    abstract renderQueue: MasterySkillRenderQueue<ActionType>;
    /** Sorted array of all mastery actions for the skill */
    sortedMasteryActions: ActionType[];
    masteryLevelUnlocks: MasteryLevelUnlock[];
    totalMasteryActions: CompletionMap;
    /** Stores a count of how many mastery actions exist in each realm */
    totalMasteryActionsInRealm: SparseNumericMap<Realm>;
    _totalCurrentMasteryLevel: CompletionMap;
    _totalCurrentMasteryLevelInRealm: SparseNumericMap<Realm>;
    /** Stores the mastery pool bonuses provided by this skill per realm */
    masteryPoolBonuses: Map<Realm, MasteryPoolBonus[]>;
    /** Stores the mastery level bonuses provided by this skill */
    masteryLevelBonuses: MasteryLevelBonus[];
    toStrang?: Pet;
    getRealmOptions(): Realm[];
    onLoad(): void;
    abstract getErrorLog(): string;
    onPageChange(): void;
    onPageVisible?(): void;
    onPageLeave?(): void;
    renderModifierChange(): void;
    queueBankQuantityRender?(item: AnyItem): void;
    /**
     * @description Rendering hook for when skill modifiers change
     * @deprecated This method will be removed in an upcoming major update. Use renderModifierChange instead.
     */
    onModifierChange(): void;
    render(): void;
    renderRealmVisibility(): void;
    renderActionMastery(): void;
    /** Queues every mastery pool in this skill for rendering */
    queueAllMasteryPoolsForRender(): void;
    renderMasteryPool(): void;
    /**
     * Callback function to level up a mastery with pool xp
     * @param action The action object to level up
     * @param levels The number of levels to increase the action by
     */
    levelUpMasteryWithPoolXP(action: ActionType, levels: number): void;
    exchangePoolXPForActionXP(action: ActionType, xpToAdd: number): void;
    /**
     * Adds mastery xp and mastery pool xp for completing an action with the given interval
     * @param action The action object to give mastery xp to
     * @param interval The interval of the action performed
     */
    addMasteryForAction(action: ActionType, interval: number): void;
    /**
     * Adds mastery xp for the specified action
     * @param action The action object to give mastery xp to
     * @param xp The experience to add to the action. Modifiers will not be applied.
     * @returns True, if the mastery level was increased
     */
    addMasteryXP(action: ActionType, xp: number): boolean;
    /**
     * Checks if a given action passes the mastery level bonus filter
     * @param action The action to check against the filter
     * @param filter The filter string
     * @returns If the action passes the filter
     */
    checkMasteryLevelBonusFilter(action: ActionType, filter: string): boolean;
    willMasteryLevelBonusChange(action: ActionType, oldLevel: number, newLevel: number): boolean;
    onMasteryLevelUp(action: ActionType, oldLevel: number, newLevel: number): void;
    /** Fires a modal indicating the skill has reached the maximum mastery level */
    fireMaximumMasteryModal(): void;
    /** Gets the base XP cap for the mastery pool for the given realm */
    getBaseMasteryPoolCap(realm: Realm): number;
    /** Gets the XP cap for the mastery pool for the given realm */
    getMasteryPoolCap(realm: Realm): number;
    /** Gets the current XP in a mastery pool for the given realm */
    getMasteryPoolXP(realm: Realm): number;
    /** Gets the percent progress in a mastery pool for the given realm */
    getMasteryPoolProgress(realm: Realm): number;
    /** Method fired when a mastery pool bonus is lost/gained */
    onMasteryPoolBonusChange(realm: Realm, oldBonusCount: number, newBonusCount: number): void;
    /** Adds Mastery Pool XP to the given realm */
    addMasteryPoolXP(realm: Realm, xp: number): void;
    /** Gets the change in mastery pool bonus level if xp is added/removed */
    getPoolBonusChange(realm: Realm, xp: number): number;
    /** Gets the number of mastery pool bonuses active based on an amount of pool xp, for the given realm */
    getActiveMasteryPoolBonusCount(realm: Realm, xp: number): number;
    /** Gets the mastery pool bonuses associated with a given realm */
    getMasteryPoolBonusesInRealm(realm: Realm): MasteryPoolBonus[];
    /** Gets the realms that this skill has actions with mastery in */
    getRealmsWithMastery(): Realm[];
    updateTotalCurrentMasteryLevel(): void;
    /** Returns the sum of all current mastery levels */
    get totalCurrentMasteryLevel(): number;
    _sortedMasteryActionsPerRealm: Map<Realm, ActionType[]>;
    /** Gets an array of mastery actions belonging to a given realm, sorted by display order */
    getSortedMasteryActionsInRealm(realm: Realm): ActionType[];
    /** Returns the sum of all current mastery levels for within a specific realm */
    getTotalCurrentMasteryLevelInRealm(realm: Realm): number;
    getTotalCurrentMasteryLevels(namespace: string): number;
    getMaxTotalMasteryLevels(namespace: string): number;
    addTotalCurrentMasteryToCompletion(completion: CompletionMap): void;
    /** The maximum total mastery level obtainable for the skill */
    get trueMaxTotalMasteryLevel(): number;
    /** The maximum total mastery level obtainable for the skill within the given Realm */
    getTrueMaxTotalMasteryLevelInRealm(realm: Realm): number;
    /** Readonly. Returns the total amount of mastery XP earned for the skill */
    get totalMasteryXP(): number;
    /** Returns the total number of actions that have mastery that are currently unlocked */
    totalUnlockedMasteryActions: number;
    /** Returns the total number of actions that have mastery that are currently unlocked within a specific realm */
    totalUnlockedMasteryActionsInRealm: SparseNumericMap<Realm>;
    /**
     * Utility method for checking if a basic skill recipe is unlocked for this skill
     * @param recipe
     */
    isBasicSkillRecipeUnlocked(recipe: RecipeLevels): boolean;
    /**
     * Returns if a given mastery action is unlocked for this skill
     * @param action The action to check
     */
    abstract isMasteryActionUnlocked(action: MasteryAction): boolean;
    /** Recomputes the values of totalUnlockedMasteryActions and totalUnlockedMasteryActionsInRealm */
    updateTotalUnlockedMasteryActions(): void;
    /** Returns the total number of actions that have mastery for this skill */
    get trueTotalMasteryActions(): number;
    /** Returns the total number of actions that have mastery for this skill within the given Realm*/
    getTrueTotalMasteryActionsInRealm(realm: Realm): number;
    /**
     * Gets the modified mastery xp to add for performing an action.
     * @param action The action object to compute mastery xp for
     * @param interval The interval of the action performed
     * @returns The modified XP to add
     */
    getMasteryXPToAddForAction(action: ActionType, interval: number): number;
    /**
     * Gets the base mastery xp to add for performing an action.
     * @param action The action object to compute mastery xp for
     * @param interval The interval of the action performed
     * @returns The modified XP to add
     */
    getBaseMasteryXPToAddForAction(action: ActionType, interval: number): number;
    /**
     * Gets the mastery XP to add to the pool for performing an action
     * @param xp The modified action mastery xp
     * @returns The mastery XP to add to the pool
     */
    getMasteryXPToAddToPool(xp: number): number;
    getMasteryXPModifier(action: ActionType): number;
    _buildMasteryXPSources(action?: NamedObject): ModifierSourceBuilder;
    getMasteryXPSources(action?: NamedObject): HTMLSpanElement[];
    getMasteryLevel(action: ActionType): number;
    getMasteryXP(action: ActionType): number;
    get isAnyMastery99(): boolean;
    constructor(namespace: DataNamespace, id: string, game: Game, actionClassName?: string);
    onAnyLevelUp(): void;
    registerData(namespace: DataNamespace, data: DataType): void;
    modifyData(data: ModificationDataType): void;
    postDataRegistration(): void;
    computeTotalMasteryActions(): void;
    getMasteryProgress(action: ActionType): MasteryProgress;
    /** Updates all mastery displays in the DOM for the given action */
    updateMasteryDisplays(action: ActionType): void;
    /** Gets the best realm to display mastery bonuses + the spend mastery XP modal on when opening */
    getBestMasteryRealm(): Realm;
    /** Callback function for opening the spend mastery xp modal */
    openSpendMasteryXPModal(): void;
    /** Callback function for opening the spend mastery xp modal */
    openSpendMasteryXPModalForRealm(realm: Realm): void;
    /** Callback function for opening the mastery level unlocks modal */
    openMasteryLevelUnlockModal(): void;
    openMasteryPoolBonusModal(): void;
    /** Opens the mastery pool bonus modal for a given realm */
    openMasteryPoolBonusModalForRealm(realm: Realm): void;
    /** Rolls for all pets that have been registered to the skill */
    rollForPets(interval: number): void;
    /** Rolls to add a mastery token to action rewards */
    rollForMasteryTokens(rewards: Rewards, realm: Realm): void;
    addProvidedStats(): void;
    getMasteryLevelSource(action: ActionType, level: number): ModifierSource;
    /** Adds the modifiers provided by this skill's mastery level bonuses to the provided modifiers object */
    addMasteryLevelBonusStats(): void;
    getMasteryPoolSource(percent: number): ModifierSource;
    /** Adds the modifiers provided by this skill's mastery pool bonuses to the provided modifiers object */
    addMasteryPoolBonusStats(): void;
    encode(writer: SaveWriter): SaveWriter;
    decode(reader: SaveWriter, version: number): void;
    /** Converts the old mastery array for the skill */
    convertOldMastery(oldMastery: OldMasteryData, idMap: NumericIDMap): void;
    abstract getActionIDFromOldID(oldActionID: number, idMap: NumericIDMap): string;
}
interface MasteryProgress {
    xp: number;
    level: number;
    percent: number;
    nextLevelXP: number;
}
/** Base class for gathering skills. E.g. Skills that return resources but does not consume them. */
declare abstract class GatheringSkill<ActionType extends MasteryAction, DataType extends MasterySkillData, Events extends SkillWithMasteryEvents = SkillWithMasteryEvents, ModificationDataType extends MasterySkillModificationData = MasterySkillModificationData> extends SkillWithMastery<ActionType, DataType, Events, ModificationDataType> implements ActiveAction, Serializable {
    /** Timer for skill action */
    actionTimer: Timer;
    abstract renderQueue: GatheringSkillRenderQueue<ActionType>;
    /** If the skill is the currently active skill */
    isActive: boolean;
    get activeSkills(): this[];
    /** Returns if the skill can currently stop */
    get canStop(): boolean;
    /** Gets the rewards for the current action of the skill */
    abstract readonly actionRewards: Rewards;
    /** Gets the interval for the next action to perform */
    abstract readonly actionInterval: number;
    /** Gets the level for the current action of the skill */
    abstract readonly actionLevel: number;
    /** Mastery Object for the currently running action */
    abstract readonly masteryAction: ActionType;
    /** If the action state should be reset after save load */
    shouldResetAction: boolean;
    /** Gets the interval of the currently running action in [ms] */
    get currentActionInterval(): number;
    /** Modified interval for mastery XP/summoning calculations */
    abstract masteryModifiedInterval: number;
    get activePotion(): PotionItem | undefined;
    /** Processes a tick of time for the skill */
    activeTick(): void;
    /** Rendering hook for when the player's equipment changes */
    abstract onEquipmentChange(): void;
    onPageChange(): void;
    onModifierChangeWhileActive?(): void;
    /** Performs rendering for the skill */
    render(): void;
    /** Gets debugging information for the skill */
    getErrorLog(): string;
    getObtainableItems(): Set<AnyItem>;
    /** Starts up the skill with whatever selections have been made. Returns true if the skill was successfully started. */
    start(): boolean;
    /** Returns true if action stopped successfully */
    stop(): boolean;
    /** Method that occurs on stopping a skill, but before saving.
     *  Usage is for state changes required
     */
    onStop(): void;
    /** Starts the timer for the skill with the actionInterval */
    startActionTimer(): void;
    /** Hook for state mutatations at start of action */
    abstract preAction(): void;
    /** Hook for state mutatations at end of action
     *  Things that should go here:
     *  Potion Usage, Glove Charge Usage, Action/Interval Statistics
     *  Renders required after an action
     *  Tutorial Tracking
     */
    abstract postAction(): void;
    /** Performs the main action for the skill, then determines if it should continue */
    action(): void;
    /** Addes rewards to player, returns false if skill should stop */
    addActionRewards(): boolean;
    /** Adds rewards that are common to all skills for a successful action */
    addCommonRewards(rewards: Rewards, action?: NamedRealmedObject): void;
    /** Adds the mastery XP reward for the current action */
    addMasteryXPReward(): void;
    resetActionState(): void;
    encode(writer: SaveWriter): SaveWriter;
    decode(reader: SaveWriter, version: number): void;
    /** Deserializes the skills state data */
    deserialize(reader: DataReader, version: number, idMap: NumericIDMap): void;
}
/** Base class for crafting skills. E.g. Skills that consume resources to make other resources. */
declare abstract class CraftingSkill<T extends MasteryAction, DataType extends MasterySkillData, Events extends SkillWithMasteryEvents, ModificationDataType extends MasterySkillModificationData = MasterySkillModificationData> extends GatheringSkill<T, DataType, Events, ModificationDataType> {
    /** Gets the costs for the currently selected recipe */
    abstract getCurrentRecipeCosts(): Costs;
    /** Records statistics for preserving resources */
    recordCostPreservationStats(costs: Costs): void;
    /** Records statistics for consuming resources */
    recordCostConsumptionStats(costs: Costs): void;
    /** Gets the message for when the player does not have the required costs for an action */
    abstract noCostsMessage: string;
    /** Performs the main action for the skill, stopping if the required resources are not met */
    action(): void;
}
declare class DummyActiveAction extends NamespacedObject implements ActiveAction {
    get name(): string;
    get media(): string;
    get activeSkills(): AnySkill[];
    getErrorLog(): string;
    isActive: boolean;
    stop(): boolean;
    activeTick(): void;
    constructor(dummyData: DummyData);
}
interface BasicSkillRecipeData extends RealmedObjectData {
    baseExperience: number;
    level: number;
    abyssalLevel?: number;
    baseAbyssalExperience?: number;
}
interface BasicSkillRecipeModificationData extends IDData {
    baseExperience?: number;
    level?: number;
    abyssalLevel?: number;
    baseAbyssalExperience?: number;
}
interface RecipeLevels {
    level: number;
    abyssalLevel: number;
}
/** Base class for skill recipes with a level requirement and fixed xp */
declare abstract class BasicSkillRecipe extends MasteryAction implements RecipeLevels {
    baseExperience: number;
    level: number;
    abyssalLevel: number;
    baseAbyssalExperience: number;
    constructor(namespace: DataNamespace, data: BasicSkillRecipeData, game: Game);
    applyDataModification(data: BasicSkillRecipeModificationData, game: Game): void;
    /** Sorting callback function for this class, that sorts by level, then by abyssalLevel */
    static sortByLevels: (a: RecipeLevels, b: RecipeLevels) => number;
}
interface SingleProductRecipeData extends BasicSkillRecipeData {
    productId: string;
}
interface SingleProductRecipeModificationData extends BasicSkillRecipeModificationData {
    productId?: string;
}
/** Base class for skill recipes that produce a single product item */
declare class SingleProductRecipe extends BasicSkillRecipe {
    get name(): string;
    get media(): string;
    product: AnyItem;
    constructor(namespace: DataNamespace, data: SingleProductRecipeData, game: Game);
    applyDataModification(data: SingleProductRecipeModificationData, game: Game): void;
}
interface SkillCategoryData extends RealmedObjectData {
    media: string;
    name: string;
}
declare class SkillCategory extends RealmedObject {
    skill: AnySkill;
    get media(): string;
    get name(): string;
    _name: string;
    _media: string;
    constructor(namespace: DataNamespace, data: SkillCategoryData, skill: AnySkill, game: Game);
}
interface SkillSubcategoryData extends IDData {
    name: string;
    nameLang?: string;
}
declare class SkillSubcategory extends NamespacedObject implements NamedObject {
    get name(): string;
    _name: string;
    _nameLang?: string;
    constructor(namespace: DataNamespace, data: SkillSubcategoryData);
}
declare class GatheringSkillRenderQueue<ActionType extends MasteryAction> extends MasterySkillRenderQueue<ActionType> {
    progressBar: boolean;
}
interface FixedCostsData {
    /** @deprecated Use currencies instead */
    gp?: number;
    /** @deprecated Use currencies instead */
    sc?: number;
    currencies?: IDQuantity[];
    items?: IDQuantity[];
}
interface ItemCurrencyLike {
    currencies?: CurrencyQuantity[];
    items?: AnyItemQuantity[];
}
/** Utility class for Defining Fixed costs */
declare class FixedCosts implements ItemCurrencyLike {
    /** Currency costs */
    currencies?: CurrencyQuantity[];
    /** Item Costs */
    items?: AnyItemQuantity[];
    constructor(data: FixedCostsData, game: Game);
}
declare type ItemCurrencyObject = {
    items: AnyItemQuantity[];
    currencies: CurrencyQuantity[];
};
/** Class to manage the item, gp, and slayer coin costs of crafting skills */
declare class Costs {
    game: Game;
    /** Returns true if all of the costs are zero */
    get isFree(): boolean;
    _items: Map<AnyItem, number>;
    _currencies: Map<Currency, number>;
    _source: string;
    constructor(game: Game);
    /** Adds an item by its unique string identifier */
    addItemByID(itemID: string, quantity: number): void;
    addItem(item: AnyItem, quantity: number): void;
    addCurrency(currency: Currency, quantity: number): void;
    /** Shortcut for addCurrency(game.gp, amount) */
    addGP(amount: number): void;
    /** Shortcut for addCurrency(game.slayerCoins, amount) */
    addSlayerCoins(amount: number): void;
    setSource(source: string): void;
    setSourceIfUnknown(source: string): void;
    /**
     * Adds an ItemCurrencyLikes costs to the costs.
     * @param costs The costs to add
     * @param multiplier Optional multiplier to all of the costs. Item costs can not be reduced below 1.
     */
    addItemsAndCurrency(costs: ItemCurrencyLike, multiplier?: number): void;
    /**
     * Gets an ItemQuantity array to interface with UI classes
     */
    getItemQuantityArray(): AnyItemQuantity[];
    /** Gets a CurrencyQuantity array to interface with UI classes */
    getCurrencyQuantityArray(): CurrencyQuantity[];
    /** Increments the skill stat provided for each currency by their amount */
    recordSkillCurrencyStats(skill: AnySkill, stat: number): void;
    /** Increments the stat provided for each currency by their amount */
    recordCurrencyStats(stat: CurrencyStats): void;
    /** Increments the stat provided by the quantity of all item costs */
    recordBulkItemStat(tracker: StatTracker, stat: number): void;
    /** Increments the stat provided by the base sale cost of all item costs */
    recordItemSkillCurrencyStat(skill: AnySkill, stat: SkillCurrencyStats): void;
    /** Increments the Item stat provided for all item costs by their quantity */
    recordIndividualItemStat(stat: ItemStats): void;
    /** Resets all stored costs */
    reset(): void;
    /** Checks if the player has all the costs */
    checkIfOwned(): boolean;
    /** Consumes all the stored costs from the player */
    consumeCosts(): void;
    /** Creates a clone of this costs object */
    clone(): Costs;
    /** Adds another costs object's costs to this one */
    addCosts(costs: Costs): void;
}
interface RewardsXP {
    noAction: number;
    action: Map<NamedObject, number>;
}
/** Class to manage the gain of rewards from crafting skills */
declare class Rewards extends Costs {
    source: string;
    actionInterval: number;
    _xp: Map<AnySkill, RewardsXP>;
    _abyssalXP: Map<AnySkill, RewardsXP>;
    addXP(skill: AnySkill, amount: number, action?: NamedObject): void;
    getXP(skill: AnySkill, action?: NamedObject): number;
    addAbyssalXP(skill: AnySkill, amount: number, action?: NamedObject): void;
    getAbyssalXP(skill: AnySkill, action?: NamedObject): number;
    setActionInterval(interval: number): void;
    /** Gives the currently set rewards to the player, returns true if not all items were given */
    giveRewards(ignoreBankSpace?: boolean): boolean;
    /** Forcefully gives the currently set rewards to the player, ignoring bank space for the items */
    forceGiveRewards(): boolean;
    reset(): void;
    setSource(source: string): void;
    static addToXPMap(xpMap: Map<AnySkill, RewardsXP>, skill: AnySkill, amount: number, action?: NamedObject): void;
    static getFromXPMap(xpMap: Map<AnySkill, RewardsXP>, skill: AnySkill, action?: NamedObject): number;
}
declare type AnySkill = Skill<any>;
